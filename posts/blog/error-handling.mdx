---
title: 에러 처리
description: 에러 처리의 중요성에 대해 알아보자 (티스토리에 게시된 글을 mdx 스타일링 확인차 가져왔다.)
date: 2023-06-09
tags: [javascript, error]

---

## 에러 처리의 필요성

에러는 언제나 발생할 수 있기 때문에 대처가 필요하다. 만약 에러를 처리하지 않을 경우 프로그램은 강제 종료된다.

```js
// ReferenceError: myName is not defined
console.log(myName); 

// TypeError: Cannot read properties of null (reading 'classList')
const button = document.querySelector('.my-button');
button.classList.add('show');
```

예외 처리를 구현하는 방법에는 예외가 발생했을 경우 null 또는 -1을 주거나, 에러 발생시 에러 처리 코드블럭으로 이동시키는 방법이 있다.

## try... catch... finally 문

try... catch... finally를 일반적인 에러 처리 방법이라 한다. try... catch... finally문은 3개의 코드 블럭으로 구성되어 있는데 finally는 생략 가능하다.

```js
try {
  // 실행할 코드
} catch (err) {
  // try 블럭에서 에러가 발생하면 catch 블럭이 실행된다.
  // 발생한 에러는 Error 객체에 담겨 err 변수에 전달된다.
} finally {
  // 에러가 발생하든 안 하든 반드시 실행된다.
}
```

## Error 객체

> const error = new Error('This is a ReferenceError');

위와 같이 생성자 함수로 에러 객체를 생성한다. 인수에 에러를 상세히 설명하는 메시지를 전달할 수 있다.

에러 객체에는 message 프로퍼티와 stack 프로퍼티가 있는데, message는 생성자 함수의 인수 값 (위에선 This is a ReferenceError)이고 stack은 에러를 발생시킨 콜스택의 호출 정보를 나타낸다.

자바스크립트가 제공하는 에러 생성자 함수는 총 7개가 있고 Error를 제외한 다른 생성자 함수는 Error를 상속받는다.

| 생성자 함수 | 인스턴스 |
| --- | --- |
| Error | 에러 객체 |
| SyntaxError | 잘못된 문법을 해석할 때 생성되는 에러 객체 |
| ReferenceError | 식별자 참조가 안 될 경우 생성되는 에러 객체 |
| TypeError | 타입이 유효하지 않을 때 생성되는 에러 객체 |
| RangeError | 숫자 값의 허용 범위를 넘었을 때 생성되는 에러 객체 |
| URIError | encodeURI 또는 decodeURI 함수에 부적절한 인수를 전달했을 때 생성되는 에러 객체 |
| EvalError | eval 함수에서 발생하는 에러 객체 |

코드에 에러 객체를 직접 생성한다고 에러가 발생하는 것은 아니다 에러 객체 생성과 에러 발생은 다르다.

## throw 문

> throw 표현식;

에러를 발생시키기 위해선 `throw`문으로 에러 객체를 던져야 한다. throw 문의 표현식은 어떤 값이라도 상관없지만 일반적으로 에러 객체를 지정한다.

```
try {
  // 이것만 실행했을 경우 catch 문으로 이동하지 않는다.
  new Error('something wrong');

  // 에러 객체를 던지면 catch 코드 블록이 실행되기 시작한다.
  throw new Error('something wrong');
} catch (error) {
  console.log(error);
}
```

## 에러의 전파

에러는 호출자(caller) 방향으로 전파된다. 즉, 콜스택의 아래 방향으로 전파된다.

```
const foo = () => {
  throw Error('foo에서 발생한 에러'); // ④
};

const bar = () => {
  foo(); // ③
};

const baz = () => {
  bar(); // ②
};

try {
  baz(); // ①
} catch (err) {
  console.error(err);
}
```

위 예제에서 baz() -> bar() -> foo() 순서로 실행되었으며 이 순서대로 콜스택이 쌓여있다. foo()에서 던져진 에러 객체는 콜스택 밑으로 내려가 try, catch 문이 있는 전역으로 이동한다.

### 주의 사항

비동기 함수(setTimeout, 프로미스)의 경우 비동기 함수 자체는 콜스택에 쌓이지 않고 태스크 큐 또는 마이크로태스크 큐에 쌓이기 때문에 `비동기 함수의 콜백 함수`는 호출자가 없다.

### 출처

모던 자바스크립트 Deep Dive (이웅모 저)